/**
 * JavaCC file
 */
 
options {
  JDK_VERSION = "1.6";
  STATIC = false;
}
PARSER_BEGIN(JCCFunctionsParser)
package parser.jcc;

import ast.*;
import java.util.ArrayList;
import java.util.List;

public class JCCFunctionsParser {
}

PARSER_END(JCCFunctionsParser)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| < MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/" >
| < SINGLE_LINE_COMMENT: "//" (~["\n"])* >
}

TOKEN : /* KEYWORDS */
{
  < CLASS: "class" >
| < PUBLIC: "public" >
| < STATIC: "static" >
| < VOID: "void" >
| < MAIN: "main" >
| < EXTENDS: "extends" >
| < IF: "if" >
| < ELSE: "else" >
| < WHILE: "while" >
| < THIS: "this" >
| < NEW: "new" >
| < PRINT: "System.out.println" >
| < INT: "int" >
| < BOOLEAN: "boolean" >
| < STRING: "String" >
| < RETURN: "return" >
}

TOKEN : /* SEPARATORS and OPERATORS*/
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < ASSIGN: "=" >
| < QUESTION: "?" >
| < COLON: ":" >
| < PLUS: "+" >
| < MINUS: "-" >
| < MULT: "*" >
| < AND: "&&" >
| < LESS: "<" >
| < NOT: "!" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < DOT: "." >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < LENGTH: ".length" >
}
	
TOKEN :	/* LITERALS */
{
  < INTEGER_LITERAL: ( <DIGIT> )+ >
| < BOOLEAN_LITERAL: "true" | "false" >
| < IDENTIFIER: <LETTER> (<LETTER> | "_" | <DIGIT>)* >
| < #LETTER: ["A" - "Z", "a" - "z"] >
| < #DIGIT: ["0" - "9"] >
}

String Identifier() : {
  Token i;
}
{
  i = < IDENTIFIER >
  { return i.image; }
}

Type Type() : {
  Token i;
}
{
  < INT >
  (    < LBRACKET >
    < RBRACKET >    { return new IntArrayType(); }  | { return new IntegerType(); }
  )| < BOOLEAN >
  { return new BooleanType(); }
| i = < IDENTIFIER >
  { return new ObjectType(i.image); }}

VarDecl VarDecl(VarDecl.Kind kind) : {
  Type type;
  String name;}
{
  type = Type()
  name = Identifier()
  < SEMICOLON >
  { return new VarDecl(kind, type, name); }}

Expression Expression() : {
  Expression e1, e2;}{
  e1 = CompareExpression()
  (    < AND >
    e2 = CompareExpression()
    { e1 = new And(e1, e2); }  )*
  { return e1; }}

Expression CompareExpression() : {
  Expression e1, e2;}{
  e1 = AddExpression()
  (    < LESS >
    e2 = AddExpression()
    { e1 = new LessThan(e1, e2); }
  )?  { return e1; }}

Expression AddExpression() : {
  Expression e1, e2;}{
  e1 = MultExpression()
  (    < PLUS >
    e2 = MultExpression()
    { e1 = new Plus(e1, e2); }  | < MINUS >
  	e2 = MultExpression()  	{ e1 = new Minus(e1, e2); }  )*
  { return e1; }}

Expression MultExpression() : {
  Expression e1, e2;}{
  e1 = NotExpression()
  (    < MULT >
    e2 = NotExpression()
    { e1 = new Times(e1, e2); }  )*
  { return e1; }}

Expression NotExpression() : {
  Expression e;}{
  < NOT >
  e = NotExpression()
  { return new Not(e); }| e = PrimaryExpression()  { return e; }}

Expression PrimaryExpression() : {
  Expression e;
  Expression index;
  String id;
  List<Expression> args = new ArrayList<Expression>();
  Expression arg;}{
  e = ElementaryExpression()
  (    < LENGTH >    { return new ArrayLength(e); }  | < LBRACKET >
  	index = Expression()
  	< RBRACKET >  	{ return new ArrayLookup(e, index); }
  | < DOT >
  	id = Identifier()
  	< LPAREN >
  	(
      arg = Expression()
      { args.add(arg); }
  	  (
  	    < COMMA >
  	    arg = Expression()
        { args.add(arg); }
      )*
    )?
    < RPAREN >
    { return new Call(e, id, new NodeList<Expression>(args)); }
  | { return e; }  )}

Expression ElementaryExpression() : {
  Token t;
  Expression e;}
{
  < NEW >
  (    t = < IDENTIFIER >
    < LPAREN >
    < RPAREN >
    { return new NewObject(t.image); }  | < INT >
  	< LBRACKET >
  	e = Expression()
  	< RBRACKET >
  	{ return new NewArray(e); }
  )| t = < INTEGER_LITERAL >  { return new IntegerLiteral(t.image); }| t = < BOOLEAN_LITERAL >
  { return new BooleanLiteral(t.image); }
| t = < IDENTIFIER >  { return new IdentifierExp(t.image); }| < THIS >  { return new This(); }
| < LPAREN >
  e = Expression()
  < RPAREN >  { return e; }
}
